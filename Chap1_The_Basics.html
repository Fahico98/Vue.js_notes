
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Chapter 1 - The Basics</title>
   </head>
   <body>

      <!------ Templates, Data, and Directives ------>

      <!--
      <div id="app">
         <h1><p v-if="hours < 12">Good morninig...!</p></h1>
         <h1><p v-if="hours >= 12 && hours < 18">Good afternoon...!</p></h1>
         <h1><p v-if="hours >= 18">Good evening...!</p></h1>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         var hours = new Date().getHours();
         new Vue({
            el: "#app",
            data: {
               hours: new Date().getHours()
            }
         });
      </script>
      -->



      <!------ v-if Versus v-show ------>

      <!--
      <div id="app">
         <div v-if="user">
            <h1>User name: {{ user.name }}</h1>
         </div>
         <div v-show="user">
            <h1>User name: {{ user.name }}</h1>
         </div>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {user: undefined}
         });
      </script>
      -->



      <!------ Looping in Templates ------>

      <!--
      <div id="app">
         <ul>
            <li v-for="dog in dogs">{{ dog }}</li>
         </ul>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               dogs: ['Rex', 'Rover', 'Henrietta', 'Alan']
            }
         });
      </script>
      -->

      <!--
      Finally, if you just want a simple counter, you can pass a number in as the argument.
      The following outputs the numbers 1 to 10:
      -->

      <!--
      <div id="app">
         <ul>
            <li v-for="n in 10">{{ n }}</li>
         </ul>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app'
         });
      </script>
      -->



      <!------ Binding Arguments ------>

      <!--
      Some directives, such as v-bind, take arguments. The v-bind directive is used to bind
      a value to an HTML attribute. For instance, the following example binds the value
      submit to the button type:
      -->

      <!--
      <div id="app">
         <button v-bind:type="buttonType">Test button</button>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               buttonType: 'submit'
            }
         });
      </script>
      -->

      <!--
      When using v-bind with a lot of attributes, it can be pretty repetitive to write it out
      multiple times. There’s a shorter way to write it: you can omit the v-bind part of the
      directive and use a colon. For example, this is how you would rewrite the preceding
      code example using the shorter syntax:
      -->

      <!--
      <div id="app">
         <button :disabled="buttonDisabled">Test button</button>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               buttonDisabled: true
            }
         });
      </script>
      -->



      <!------ Reactivity ------>

      <!--
      In addition to creating the HTML in the first place, Vue watches the 'data' object for
      changes and updates the DOM when the data changes. To demonstrate this, let’s
      make a simple timer app that tells you how long the page has been open. We’ll need
      only one variable, which we’ll call seconds, and we’ll use 'setInterval' to increment
      that variable once a second:
      -->

      <!--
      <div id="app">
         <p>{{ seconds }} seconds have elapsed since you opened the page.</p>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               seconds: 0
            },
            created(){
               setInterval(() => {
                  this.seconds++;
               }, 1000);
            }
         });
      </script>
      -->



      <!------ Two-Way Data Binding ------>

      <!--
      <div id="app">
         <input type="text" v-model="inputText">
         <p>inputText: {{ inputText }}</p>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               inputText: 'initial value'
            }
         });
      </script>
      -->

      <!--
      <div id="app">
         <input type="text" value="initial value" v-bind:value="inputText">
         <p>inputText: {{ inputText }}</p>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               inputText: 'initial value from data object...!'
            }
         });
      </script>
      -->



      <!------ Computed Properties ------>

      <!--
      'Computed propertie' sit halfway between properties of the data object and methods:
      you can access them as if they were properties of the data object, but they are specified
      as functions.
   
      But what’s the difference between using computed properties and methods, aside
      from the obvious syntax difference? Well, there are a couple.

      The first is that computed properties are cached: if you call a method multiple times
      in a template, the code inside the method will be run every single time the method is
      called, whereas if a computed property is called multiple times, the code inside will be
      run only once, and every time after that, the cached value will be used. The code will
      be run again only when a dependency of the method changes: for example, in the
      previous code sample, if we push a new item to basketItems, the code inside basket
      Total is run again to get the new value.
      -->

      <!--
      <div id="app">
         <p>Sum of numbers: {{ numberTotal }}</p>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               numbers: [5, 8, 3]
            },
            computed: {
               numberTotal() {
                  return numbers.reduce((sum, val) => sum + val);
               }
            }
         });
      </script>
      -->



      <!------ Watchers ------>
      
      <!--
      Watchers allow us to watch a property of the data object or a computed property for
      changes.
      -->

      <!--
      <div id="app">
         <input type="text" v-model="inputValue">
         <p>Five seconds ago, the input said "{{ oldInputValue }}".</p>
      </div>
      
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               inputValue: '',
               oldInputValue: ''
            },
            watch: {
               inputValue(){
                  const newValue = this.inputValue;
                  setTimeout(() => {
                     this.oldInputValue = newValue;
                  }, 5000);
               }
            }
         });
      </script>
      -->



      <!------ Filters ------>

      <!--
      Filters, also often seen in other templating languages, are a convenient way of
      manipulating data in your templates. I find them great for making simple display
      changes to strings and numbers: for example, changing a string to the correct case
      or displaying a number in a human-readable format.
      
      Take the following code sample:
      -->

      <!--
      <div id="app">
         <p>Product one cost: ${{ (productOneCost / 100).toFixed(2) }}</p>
         <p>Product two cost: ${{ (productTwoCost / 100).toFixed(2) }}</p>
         <p>Product three cost: ${{ (productThreeCost / 100).toFixed(2) }}</p>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               productOneCost: 998,
               productTwoCost: 2399,
               productThreeCost: 5300
            }
         });
      </script>
      -->

      <!--
      It works, but there’s a lot of duplication. For every item, we’re doing the math to convert
      it from cents to dollars, displaying it to two decimal places, and adding the dollar
      sign. Although we can definitely split that logic into a method, this time we’ll split
      that logic into a filter, as it’s more readable and can be added globally:
      -->

      <!--
      <div id="app">

         <p>Product one cost: {{ productOneCost | formatCost }}</p>
         <p>Product two cost: {{ productTwoCost | formatCost }}</p>
         <p>Product three cost: {{ productThreeCost | formatCost }}</p>

         <p>Product one cost: {{ formatCost(productOneCost) }}</p>
         <p>Product two cost: {{ formatCost(productTwoCost) }}</p>
         <p>Product three cost: {{ formatCost(productThreeCost) }}</p>

      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               productOneCost: 998,
               productTwoCost: 2399,
               productThreeCost: 5300
            },
            /*
            filters: {
               formatCost(value){
                  return '$' + (value/100).toFixed(2);
               }
            }
            */
            methods: {
               formatCost(value){
                  return '$' + (value/100).toFixed(2);
               }
            }
         });
      </script>
      -->

      <!--
      You can use multiple filters in the same expression by chaining them together. For
      example, if we have a 'round' filter that rounds a number to the nearest integer, you
      could use both filters together by writing {{ productOneCost | round | formatCost }}.
      -->



      <!------ Inputs and Events ------>

      <!--
      To bind an event listener to an element, you can use the v-on directive. It takes the
      name of the event as the argument, and the event listener as the passed value. For
      example, to increase the value of counter by one when a button is clicked, you can
      write the following:
      -->

      <!--
      <div id="app">
         <button v-on:click="increase">Click to increase counter</button>
         <p>You've clicked the button <strong>{{ counter }}</strong> times...!</p>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               counter: 0
            },
            methods: {
               increase(e) {
                  this.counter++;
               }
            }
         });
      </script>
      -->



      <!------ Life-Cycle Hooks ------>

      <!--
      You’ve seen a couple of times now that if you specify a function as the 'created'
      property on a component or your Vue instance, it is called when the component is, well,
      created. This is an example of what’s known as a life-cycle hook, a series of functions
      that are called at various points throughout the life cycle of a component—all the way
      from when it created and added the DOM, to when it is destroyed.

      Here’s the basic life cycle of an object: first, the Vue instance is initiated when new
      Vue() is called. The first hook, beforeCreate, is called, and reactivity is initiated.
      Then the created hook is called—you can see how this works with the hook names. The
      “before” hook is called before the thing that triggers the hook happens, and then the
      actual hook is called afterward. Next, the template is compiled—either from the template
      or render options, or from the outerHTML of the element that Vue was initialized to. The
      DOM element is now ready to be created, so the beforeMount hook is fired, the element is
      created, and then the mounted hook is fired.

      One thing to be careful of is that as of Vue 2.0, the mounted hook doesn’t guarantee
      that the element has been added to the DOM. To make sure that it has been added, you can
      call Vue.nextTick() (also available as this.$nextTick()) with a callback method containing
      the code you want to run after the element is definitely added to the DOM. For example:
      
      <div id="app">
         <p>Hello world</p>
      </div>
      <script>
         new Vue({
            el: '#app',
            mounted(){
            
               // Element might not have been added to the DOM yet

               this.$nextTick(() => {
               
                  // Element has definitely been added to the DOM now

               });
            }
         });
      </script>

      • beforeCreate is fired before the instance is initialized.
      
      • created is fired after the instance has been initialized but before it is added to the DOM.
      
      • beforeMount is fired after the element is ready to be added to the DOM but before it has
      been.
      
      • mounted is fired after the element has been created (but not necessarily added to the DOM:
      use nextTick for that).

      • beforeUpdate is fired when there are changes to be made to the DOM output.
      
      • updated is fired after changes have been written to the DOM.
      
      • beforeDestroy is fired when the component is about to be destroyed and removed from the DOM.
      
      • destroyed is fired after the component has been destroyed.
      -->
      


      <!------ Custom Directives ------>

      <!-- Example 1 -->

      <!--
      <div id="app">
         <h1 v-rainbow>{{ title }}</h1>
         <h1 v-rainbow>{{ title }}</h1>
         <h1 v-rainbow>{{ title }}</h1>
         <h1 v-rainbow>{{ title }}</h1>
         <h1 v-rainbow>{{ title }}</h1>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               title: "Custom Directives Example 1...!"
            },
            directives: {
               rainbow: {
                  bind(el, binding, vnode){
                     el.style.color = "#" + Math.random().toString().slice(2, 8);
                  }
               }
            }
         });
      </script>
      -->

      <!-- Example 2 -->

      <!--
      <div id="app">
         <div v-theme="'wide'">
            <h1>{{ title }}</h1>
         </div>
         <div v-theme="'narrow'">
            <h1>{{ title }}</h1>
         </div>
         <div v-theme:column="'wide'">
            <h1>{{ title }}</h1>
         </div>
      </div>
      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>
      <script>
         new Vue({
            el: '#app',
            data: {
               title: "Custom Directives Example 2...!"
            },
            directives: {
               theme: {
                  bind(el, binding, vnode){
                     if(binding.value == "wide"){
                        el.style.maxWidth = "1200px";
                        el.style.background = "lightblue";
                     }else if(binding.value == "narrow"){
                        el.style.maxWidth = "920px";
                        el.style.background = "lightgreen";
                     }
                     if(binding.arg == "column"){
                        el.style.maxWidth = "560px";
                        el.style.background = "orange";
                     }
                  }
               }
            }
         });
      </script>
      -->



      <!------ CSS Transitions ------>

      <!--
      Vue provides a transition wrapper component, allowing you to add entering/leaving transitions
      for any element or component in the following contexts:

      -> Conditional rendering (using v-if)
      -> Conditional display (using v-show)
      -> Dynamic components
      -> Component root nodes

      This is what an example looks like in action:
      -->

      <!--
      <div id="demo">
         <button v-on:click="show = !show">
           Toggle
         </button>
         <transition name="fade">
           <p v-if="show">hello</p>
         </transition>
      </div>

      <script src="https://unpkg.com/vue@2.6.11/dist/vue.js"></script>

      <script>
         new Vue({
            el: '#demo',
            data: {
               show: true
            }
         });
      </script>

      <style>
         /*
         enter-active: 
         */
         .fade-enter-active, .fade-leave-active {
            transition: opacity 0.2s;
         }
         .fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {
            opacity: 0;
         }
      </style>
      -->

   </body>
</html>